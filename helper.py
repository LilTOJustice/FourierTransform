import cmath
import math
import struct
import numpy as np

#generates a waveform in the form of a list of intensity samples (-1 to 1) over 1 second
#Each frequency in the frequencies list is composed, then the final result is normalized
def create_waveform(frequencies : list, amp_shift: float):
    sample_rate = 44100 #use standard sample rate
    num_samples = int(sample_rate) #1 second
    g = [0 for i in range(num_samples)]
    for f in frequencies: #compose all frequencies
        for i in range(num_samples):
            t = i/sample_rate
            g[i] += math.cos(2*math.pi*f*t)
    highest_sample = max(g)
    g = [f/highest_sample+amp_shift for f in g] #normalize each sample
    return g

#Used to prompt what times t0 and t1 should be sampled from the file to perform the FT
def prompt_time_interval(duration):
    while True:
        t0 = float(input('Sample start time: '))
        if t0 < 0 or t0 > duration:
            print('INVALID TIME(S)')
            continue
        t1 = input('Sample end time (type max to go to the end): ')
        if t1 == 'max':
            t1 = duration
        else:
            t1 = float(t1)
        if t0 > t1 or t1 > duration:
            print('INVALID TIME(S)')
            continue
        break
    return (t0, t1)

#Used to prompt what frequency will be generated by the create_waveform function
def prompt_waveform():
    frequencies = []
    while True:
        frequency = input('Input a frequency to compose (can be float or int) or -1 to finish inputting frequencies:\n')
        try:
            frequency = float(frequency.strip(' '))
            if frequency == -1:
                if len(frequencies) == 0:
                    print('Need at least one frequency!')
                    continue
                break
            if frequency <= 0:
                raise Exception('')
            frequencies.append(frequency)
        except:
            print('Invalid frequency value found:', frequency)
    return frequencies

#Reads samples indexed by the starting sample and runs until the total samples in the range have been read
def read_samples(wav, starting_sample, tot_samples):
    samples = []
    wav.setpos(starting_sample)
    for i in range(tot_samples):
        wav_read = struct.unpack("<h", wav.readframes(1))[0] #reads backwards! must reverse to little endian (yep, looks like pythonstdlib reads wav bytes backwards :/)
        samples.append(wav_read)
    return samples

#calculates the complex numbers for winding the function g at the given winding frequency throughout the given time interval
def calc_complex(g, winding_freq, t_range):
    complex_vals = []
    for i in range(len(g)):
        t = t_range[i]
        g_of_t = g[i]
        complex_vals.append(g_of_t*cmath.exp(-2*cmath.pi*complex(0,1)*winding_freq*t))
    center = sum(complex_vals)/len(complex_vals)
    reals = np.array([c.real for c in complex_vals])
    imags = np.array([c.imag for c in complex_vals])
    return (reals, imags, center)

def calc_center_mags(g, t_range):
    center_mags = []
    for winding_freq in range(1, 101):
        center = calc_complex(g, winding_freq, t_range)[2]
        center_mags.append(abs(center))
    return center_mags
